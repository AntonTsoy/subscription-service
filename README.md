# subscription-service

Go REST-сервис для CRUDL операций с онлайн-подписками пользователей. Позволяет создавать, обновлять, удалять и просматривать подписки, а также рассчитывать общую стоимость подписок с опциональной фильтрацией по пользователю и сервису.

## Используемые технологии

- **Go 1.23** - основной язык
- **Chi** - роутер для HTTP API
- **sqlx** - работа с БД
- **PostgreSQL** - база данных
- **golang-migrate** - миграции
- **Swagger (swaggo)** - документация API
- **Docker + docker-compose** - контейнеризация и оркестрация

## Запуск

1. Клонирование репозитория
```bash
git clone https://github.com/AntonTsoy/subscription-service.git
cd subscription-service
```

2. Написать .env файл. Можно использовать мой, его я специально загрузил в репозиторий:
```bash
# Контейнер PostgreSQL
POSTGRES_USER=service
POSTGRES_PASSWORD=never_guess_password
POSTGRES_DB=subs

# Подключение приложения к БД
DB_HOST=db
DB_PORT=5432
DB_USER=${POSTGRES_USER}
DB_PASSWORD=${POSTGRES_PASSWORD}
DB_NAME=${POSTGRES_DB}
DB_SSL=disable
```

3. Собрать и запустить сервис
```bash
docker compose up --build
```

4. Приложение будет доступно на http://localhost:8080

5. Swagger-документация доступна по адресу http://localhost:8080/swagger/index.html

## API

### Создание подписки
```bash
POST /subscriptions
```

Сервис позволяет создавать несолько активных подписок для пользователя на один сервис с пересекающимися интервалами.

**Пример тела запроса**:
```json
{
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "service_name": "Netflix",
    "price": 542,
    "start_date": "07-2025",
    "end_date": "09-2025"
}
```
`end_date` может быть `null`, если подписка бессрочная.

**Пример успешного ответа (201 Created)**:
```json
{
    "id": 1,
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "service_name": "Netflix",
    "price": 542,
    "start_date": "07-2025",
    "end_date": "09-2025"
}
```

### Получение подписки по ID
```bash
GET /subscriptions/{id}
```

**Пример успешного ответа (200 OK)**:
```json
{
    "id": 1,
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "service_name": "Netflix",
    "price": 542,
    "start_date": "07-2025",
    "end_date": "09-2025"
}
```

**Ошибки**:
- **400 Bad Request** — неверный формат ID.
- **404 Not Found** — подписка не найдена.


### Получение списка подписок с пагинацией
```bash
GET /subscriptions?limit={limit}&offset={offset}
```

Я решил добавить пагинацию для этого запроса, чтобы добавить контроль по нагрузке на БД. Параметры `limit` и `offset` можно не указывать.
- `limit` — максимальное количество элементов (по умолчанию 100).
- `offset` — смещение от начала списка (по умолчанию 0).

### Обновление подписки по ID
```bash
PUT /subscriptions/{id}
```

**Пример тела запроса**:
```json
{
    "service_name": "Netflix Premium",
    "price": 750,
    "start_date": "08-2025",
    "end_date": "12-2025"
}
```

**Ошибки**:
- **400 Bad Request** — некорректные данные.
- **404 Not Found** — подписка не найдена.

Я решил не добавлять тело ответа для этого запроса в случае успеха. Поэтому ручка возвращает **204 No Content**

### Удаление подписки по ID
```bash
DELETE /subscriptions/{id}
```

Статус при успешном исходе также: **204 No Content**

**Ошибки**:
- **400 Bad Request** — неверный ID.
- **404 Not Found** — подписка не найдена.

### Подсчет суммарной стоимости всех подписок за выбранный период
```bash
GET /subscriptions/{start}/{end}/total-cost?user_id={user_id}&service_name={service_name}
```
`start` и `end` — даты в формате `MM-YYYY`.

Как я понял фильтрация по сервису и пользователю должна была быть необязетельным пунктом для этого запроса, поэтому `user_id` и `service_name` добавил, как необязательные параметры.

**Пример ответа (200 OK)**:
```json
{
    "totalCost": 2048
}
```

Особенность реализации, логика подсчёта:
- Из БД выбираются все подписки, которые пересекаются с указанным периодом.
- В слое бизнес-логики вычисляется количество месяцев пересечения.
- Итоговая стоимость = price * количество_месяцев.
- В ответ возвращается сумма по всем найденным подпискам.

Например:
1. От клиента пришел интервал "07-2025" - "09-2025" (подписки на июлю, август и сентябрь 2025)
2. В БД сохраена подписка с интервалом "08-2025" - "09-2025" (подписка на сервис на август и сентябрь 2025)
3. Стоимость этой подписки будет посчитана как `price * 2` - стоимость за 2 месяца
4. В ответ попадёт двойная стоимость месячной подписки

### Особенность валидации
По ТЗ и общению с тех.поддержкой я понял, что предполагается, что сервис будет внутренним. И запросы будут идти правильного формата и внешние пользователи не будут иметь доступа к API. Поэтому я реализовал только минимальную валидацию данных, чтобы было соответствие типов.

## Архитектура

### Структура проекта

- `cmd/app` — **точка входа**, здесь инициализируется приложение: загрузка конфигурации, подключение к БД, настройка роутов и запуск HTTP-сервера.
- `internal/config` — **конфигурация** приложения (чтение переменных окружения).
- `internal/database` — **подключение к базе данных** через `sqlx`, настройка пула соединений и healthcheck.
- `internal/repository` — **доступ к БД**: SQL-запросы, работа с моделями.
- `internal/service` — **бизнес-логика**: правила работы с подписками.
- `internal/transport/handler` — **HTTP-обработчики** (REST API). Здесь только парсинг запроса, вызов сервисного слоя и формирование ответа.
- `internal/transport/dto` — **Data Transfer Objects** для входных и выходных данных API. Я отедлил внутренние модели (`models.Subscription`) от публичных контрактов API.
- `internal/transport/logger` — **middleware для логирования**: логирует все запросы (метод, путь, статус, длительность), а также ошибки.
- `migrations` — **SQL-миграции** (управляются через `golang-migrate`, запускаются отдельным контейнером).
- `docs` — **Swagger-документация** для REST API, сгенерированная через `swaggo`.

### Разделение на слои

Архитектура проекта организована по принципу **чистой архитектуры / onion-style** с разделением ответственности:

1. **Handler (transport)**
    - Принимает HTTP-запрос.
    - Парсит параметры, query, body.
    - Делегирует выполнение в `service`.
    - Возвращает клиенту результат в виде JSON.
2. **Service (application logic)**
    - Ядро приложения.
    - Содержит бизнес-правила: например, расчёт стоимости подписок за период.
    - Работает с репозиторием, но не знает деталей SQL.
    - Возвращает в handler «готовый результат».
3. **Repository (data access)**
    - Отвечает за доступ к данным.
    - Хранит SQL-запросы (CRUD).
    - Не содержит бизнес-логики, только получает или изменяет данные.
    - Общается с БД через `sqlx`.

## БД и Миграции

### Схема БД
В проекте используется одна основная таблица - **`subscriptions`**, которая хранит информацию о пользовательских подписках:
```sql
CREATE TABLE subscriptions (
    id SERIAL PRIMARY KEY,
    service_name TEXT NOT NULL,
    price INTEGER NOT NULL,
    user_id UUID NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE
);
```

### Индекc
```sql
CREATE INDEX idx_subs_service_dates ON subscriptions (start_date, end_date, user_id, service_name);
```

Используется при запросах:
- получения списка подписок конкретного пользователя за период,
- вычисления общей стоимости подписок в диапазоне дат.

Ускоряет фильтрацию по диапазонам дат и дополнительным условиям (`user_id`, `service_name`).

### Миграции

Для управления схемой БД используется **golang-migrate**
- Все миграции хранятся в папке `migrations`
- Миграции запускаются через отдельный контейнер в `docker-compose` (сервис `migrate`).
- При старте проекта:
    1. Сначала поднимается контейнер с PostgreSQL (`db`).
    2. После успешного `healthcheck` применяется команда `migrate up`.
    3. Только после этого запускается приложение (`app`).

## Подробнее о реализации

### DTO-шки на уровне API

В проекте я добавил работу с **DTO** для входных и выходных данных HTTP API:
- Входные структуры (`dto.SubscriptionRequest`, `dto.TotalSubscriptionsCostRequest`) описывают формат тела запроса и query-параметров.
- Структура `dto.SubscriptionResponse` определяет контракт ответа, который возвращается клиенту.

### Использование `context.Context` с таймаутом на каждый запрос

Я хотел позаботиться об обработке висячих запросов. Поэтому к `context.Context` HTTP-запроса от сервера через middleware выставляется таймаут на каждый запрос - 10 секунд.

### Middleware для логирования запросов

Для логирования реализован отдельный middleware, который:
1. Присваивает каждому запросу уникальный **RequestID** (UUID). Чтобы легко сопоставить все события, относящиеся к одному запросу (входной запрос, ошибки, ответ)
2. Логирует основные параметры запроса:
    - HTTP метод
    - полный путь URL,
    - HTTP-статус ответа,
    - время выполнения.
3. Добавляет RequestID в `context.Context`, чтобы можно было использовать его в хэндлерах при логировании ошибок.

### Что нужно поправить

- Ошибку вычисления суммарной стоимости (не учитываю года). Перенести агрегацию суммарной стоимости на сторону БД.
- Поделить логи на уровни
- Добавить graceful shutdown
- Покрыть код тестами
